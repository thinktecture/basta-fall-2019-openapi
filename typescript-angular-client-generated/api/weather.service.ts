/**
 * OpenAPI Sample API v2
 * Sample API for an OpenAPI conference talk.</br>This document was automatically generated as of 25.09.2019 06:32:09.
 *
 * OpenAPI spec version: v2
 * Contact: sebastian.gingter@thinktecture.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { WeatherForecastPagedResult } from '../model/weatherForecastPagedResult';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class WeatherService {

    protected basePath = '/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Gets a user-defined page of weather forecasts.
     * 
     * @param skip The amount of forecasts to skip.
     * @param take The amount of forecasts to take.
     * @param correlationId Optional correlation id. Can be any string. Should be unique per call. If provided, all logging will use this id to be able to correlate requests spanning multiple services.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public apiV2WeatherForecastGet(skip: number, take: number, correlationId?: string, observe?: 'body', reportProgress?: boolean): Observable<WeatherForecastPagedResult>;
    public apiV2WeatherForecastGet(skip: number, take: number, correlationId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<WeatherForecastPagedResult>>;
    public apiV2WeatherForecastGet(skip: number, take: number, correlationId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<WeatherForecastPagedResult>>;
    public apiV2WeatherForecastGet(skip: number, take: number, correlationId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (skip === null || skip === undefined) {
            throw new Error('Required parameter skip was null or undefined when calling apiV2WeatherForecastGet.');
        }

        if (take === null || take === undefined) {
            throw new Error('Required parameter take was null or undefined when calling apiV2WeatherForecastGet.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (skip !== undefined && skip !== null) {
            queryParameters = queryParameters.set('skip', <any>skip);
        }
        if (take !== undefined && take !== null) {
            queryParameters = queryParameters.set('take', <any>take);
        }

        let headers = this.defaultHeaders;
        if (correlationId !== undefined && correlationId !== null) {
            headers = headers.set('correlation-id', String(correlationId));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'text/plain',
            'application/json',
            'text/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<WeatherForecastPagedResult>(`${this.basePath}/api/v2/WeatherForecast`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
